---
layout: post
title: "MiddlePolice and mbox"
data: 2019-05-15
tags: [security， web_security]
excerpt: "阅读笔记"
comments: false
share: false
---

计算机网络课程论文阅读分享

## 一、文章简介

Practical Proactive DDoS-Attack Mitigation viaEndpoint-Driven In-Network Traffic Control

通过端点驱动的网络流量控制，实现DDOS攻击缓解

Author:Zhuotao Liu , Hao Jin, Yih-Chun Hu, and Michael Bailey

IEEE/ACM TRANSACTIONS ON NETWORKING, VOL. 26, NO. 4, AUGUST 2018

通讯作者，[ZhuotaoLiu](https://orcid.org/0000-0002-7532-0434)，毕业于伊利诺伊大学厄巴纳 – 香槟分校，2017至今在谷歌公司工作，论文发表于2018年。在2019年又发表了一篇在ISP部署的DDOS防御服务的论文。

---

## 二、DDOS简介

DDOS不是某一种攻击，而是某一类攻击，常见的攻击类型有：

1. 针对于带宽容量的攻击

2. 对服务器资源的攻击

第一种攻击的典型例子为放大攻击，第二种攻击的典型例子为SYN泛洪攻击。文章所提出的是针对于第一种攻击的缓解系统

---

## 三、文章要解决的问题

对于DDOS防御系统，作者做了一个大规模的行业调查，得出如下结论（节取）：

1. 企业对于学术研究成果的利用率很低

2. 大部分企业选择的是使用ISP的DDOS防御服务

导致第一个结论的原因是，过去的研究要求企业在网络上进行大规模的部署升级，受限于成本等原因，很多企业并没有这么做，而是使用了第三方提供的DDOS防御服务。

而对于第三方提供的DDOS防御服务，有如下的缺陷：

1. 有些组织，如医院政府难以使用这种服务，因为他们不想公开他们的流量

2. 其次，在服务器IP地址暴露的情况下，企业会遭受到旁路攻击

3. 最后，这些DDOS服务只能执行单一的流量管理策略，而企业对自己的流量有更多的认识，由此企业不能做出更好的过滤

综合上述提出的要点，文章以解决这些问题为前提，提出了一种新的系统，这个系统的目标包括：

1. 便于部署

2. 可以抵御旁路攻击

3. 可以执行基于目标驱动的流量管理策略

### 便于部署的体现

![Alt 过去学术研究](过去学术研究.png)

上图，列出了不同的DDOS防御策略的1~2个典型方法和他们对于设备的部署要求，其中MIddlePolic是文章提出的系统，可以看出，MiddlePolice对设备的部署要求是很低的

---

## 四、系统概览

![Alt 系统概览](系统概览.png)

上图是系统概览，其中mbox和packet filtering是系统的一部分

用户的流量先通过mbox，mbox给每个用户维护了一个速率窗口，这个窗口决定了，在这个周期内，用户至少可使用流量。也就是说，mbox决定了每个用户可通过的流量。通过了mbox的流量再去到包过滤器，最后到达目标服务器。

系统的主要目的是，当目标服务器受到DDOS攻击时（mbox或者包过滤器），mbox可以保证普通用户拥有足够的转发流量，同时越来越少地转发攻击者的流量

---

## 五、系统设计

为了达到上述目的，系统要解决两个问题：探测mbox到目标服务的可用带宽；根据流量管理策略，将获取的可用带宽分配到每个连接的用户

### 1. 探测带宽

探测带宽要解决过高估计的问题，过高估计指的是mbox过高地估计了下游可用带宽，最后导致的后果是，下游拥塞，系统设置的流量管理策略失去作用

文章使用了一种可访问性反馈机制来解决过高估计的问题：

发送方A要发送数据到目标服务器，当数据包经过mbox的时候，mbox给这个数据包生成一个唯一标识，并通过package-in-package的方法，将这个标识添加到数据包里面，然后发送给CHM（capaility handing module），CHM剥离标识，转发原来的数据包到目标服务器，并将标识返回给mbox

这么定义*下游丢失的包*：如果在RRT内没有收到返回的标识，mbox就认为这个包是丢失的

那么，*下游可用带宽*可以这么估计：在一个时间间隔内，统计mbox从所有发送方接收到的数据包总数以及下游丢失的包的数量，两者之差就是下游可用带宽（其实也就是CHM返回的标识数量）

这样的估计方法，肯定不会超过下游的最大可用带宽，因为我们是根据CHM返回的标识来估计的。

### 2. 带宽分配

带宽分配要解决过低估计的问题，过低估计指的是mbox低估了用户要使用的流量。由于过高估计获取的可用带宽是根据下游返回的标识来决定的，当用户的总发送流量低于探测得到的可用带宽，这不会有什么问题，而当用户的总发送流量高于探测得到的可用带宽，由于不知道此时下游是否还有可以使用的带宽，如果丢弃了多余的流量，会导致网络资源浪费以及网络性能下降

举个例子

过高估计可以返回下游可用带宽，比如说10，然而下游实际可用最大带宽是100，假设此时只有一个用户A连接到mbox，那么mbox将这个10个带宽都分配给用户A，当他将分配到的可用带宽使用完了，后续发送的包都会被mbox丢弃，只有等到下一个周期刷新，用户A才会重新获得可用带宽

解决过低估计，其实就是要决定多余流量是否要丢弃的问题

将mbox分配到每个用户可以使用的流量称为速率窗口，WR，每个mbox都给每个连接的用户分配一个WR

将通过这个窗口的数据包称为特权包，将WR之外的数据包，也就是多余的包称为最努力包

定义单个用户到mbox的丢包率为LLR，单个mbox到下游的丢包率为SLR。通过设定阈值，LLR可以反映每个用户的发包情况而SLR可以反应下游的拥堵情况

过低估计的问题就是要决定最努力包是否需要被丢弃的问题，最努力包是否需要被丢弃，依赖LLR，和SLR：如果LLR超过了阈值，则说明，此时发送方已经发送了大量包，mbox丢弃这个最努力包；如果SLR超过了阈值，则说明，此时下游是拥塞的，mbox也会丢弃这个最努力包；只有两个数值都没有超过阈值的情况，最努力包才会被转发

通过这个方法，即使分配给用户的wr被低估了，用户任然可以发送数据包到目标服务器

### 3. mbox详细设计

通过解决这两个基本问题，可以得到系统的基本模型，可以看出，mbox是系统里面流量控制的核心。

而，流量控制的关键是WR的计算和分配，这是mbox完成流量管理的最主要工作。计算需要依赖于mbox存储的其他变量，以及用户选择的流量管理策略（带宽分配策略）。

实际上，大部分的变量都存储在一个表里面

接下来就描述，mbox如何存储、计算这些变量。我会先描述这些变量的具体定义，然后我会描述流量控制的逻辑，以此来说明各个变量填充的顺序和计算方法，最后将流量控制的逻辑转化为算法的描述。

#### 信息表 - iTable

整个系统流量管理的基础是，每个mbox维护一个信息表 - iTable

f| TA | Pid | NR | ND | WR | WV | LR
:-: |:-:|:-:|:-:|:-:|:-:|:-:|:-:
64 | 32 | 16 | 32 | 32  |32 | 128 | 64

设发送方为`si`，表格中每一行对应着一个发送方，对应的唯一标识符是`f`

除了`f`之外，其余的字段在每个检测期间都会更新

`TA`，时间戳，记录当前的检测周期

`Pid`，为`si`生成*独特标识*的最大数量

`NR`，存储从`si`接收的数据包数量

`ND`，mbox丢弃的最努力包数量

`WR`，速率窗口，特权包的最大数量

`WV`，验证窗口，用于计算`si`的丢包率LLR

`LR`，存储`si`的丢包率，即`si`的LLR

f,TA,Pid主要用于生成标识

NR,ND主要用于计算SLR、区分特权包，最努力包

WV,LR主要用于计算LLR

标识用以辅助计算SLR和LLR，LLR和SLR交给流量管理算法，计算WR，最后WR控制发送方si的发送流量，达成目的

#### 标识 - capability

（我将capability理解为标识）

mbox会给发送方A发送过来的数据包生成一个唯一标识，这个标识要么是独特标识，要么是公共标识

*独特标识*的计算如下：

```bash
C = IPMP || ts || Pid || f || TA || MAC_Ks(IPMP || ts || Pid || f || TA)
```

其中

`IPMP`，发出c的mbox的IP地址

`ts`， 当前时间戳

`Pid || f || TA`，这是一个组合，这个组合保证C的唯一性

`MACKs()`，基于所有mbox共享的秘钥`Ks`进行计算

`MAC_KS`占128位，整个C占用约300位

*公共标识*的计算如下：

```bash
Cc = IPMP || ts || MAC_Ks(IPMP || ts)
```

#### 系统变量

Dp| Th_cap | Th_rtt | Th_drop_slr | B | Th_lpass | S_slr
:-: |:-:|:-:|:-:|:-:|:-:|:-:
4s | 128 | 1s | 0.05 | 0.8 | 5 | 100

`Dp` 检测周期的长度

`Th_cap` 标识ID的上限

`Th_rtt` 标识反馈的最大等待时间

`Th_drop_slr` 丢弃最佳努力包的阈值

`Β` 历史损失率的权重

`Th_lpass` 计算LLR的阈值

`S_slr` cTable的长度限制

#### 流量控制逻辑

整个功能从填充iTable开始

第一种情况，iTable里面没有si的记录，在ts时刻，一个新的发送方si发送一个数据包到mbox：

1. 计算f

    f根据si的声称的地址来计算。其余字段初始化为0。

2. 将TA更新为ts；Pid和NR加1，反映数据包到达情况

3. 最后计算标识，发送数据包

这里，Pid是可以直接加1的，因为第一个数据包肯定是特权包

第二种情况，iTable里面已经有si的记录，在ta时刻，si给mbox发送了一个数据包

1. 计算f
2. 在iTable里面检索f
3. Pid和NR加1，计算标识
4. 如果满足条件：ta-TA>Dp，则开启一个新的检测周期，更新其余字段

    剩下的字段要么是用来辅助计算SLR和LLR，要么是依赖SLR和LLR

所以接下来，解释LLR和SLR的计算方法

#### LLR

LLR指的是，在单个周期内，si的丢包率

LLR的计算依赖与两个变量：

- 标识
- 标识的反馈验证 - WV

整体思路是：我们给每一个数据包生成一个与之对应的唯一标识，在WV上记录这个标识有没有返回到mbox，最后结合WV的记录信息以及其他的变量计算LLR

在进一步说明*计算标识*之前，先看看LLR的具体计算公式

LLR指定是，在单个周期内，si的丢包率，所以，LLR可以表示为：

LLR = (一个周期内si丢失的包的总数)/(一个周期内si发送的包的总数)

- 什么是单个周期内si丢失的包的总数？

    这里包含了两部分的包

    第一部分丢失的包是在通过mbox之前丢弃的最努力包

    第二部分丢失的包，是通过mbox之后（特权包+最努力包），在下游链路丢失的包

- 什么是下游链路丢失的包？

    在上面解决过高估计的时候，我们提过这个问题，我们说，所有在周期内，没有返回到mbox的标识，都被认为是丢失的包

    然而这个定义是不够准确的。在一个周期内，从mbox到CHM的数据包有三种情况：

    1. 在单个周期内，携带标识的数据包没有足够的时间发送到目标服务器

        也就是说，数据包在发送的途中，这个周期就结束了

    2. 在单个周期内，携带标识的数据包有足够的时间发送到目标服务器，但是标识没有足够的时间返回mbox

        也就是说，标识在返回的途中，这个周期就结束了

    3. 在单个周期内，携带标识的数据包有足够的时间发送到目标服务器，并且标识有足够的时间返回mbox

    而，第一种情况和第二种情况的数据包，不能满足我们的要求，因为周期的提前结束会导致标识的丢失，在这两种情况下，标识的丢失不能充分地说明，下游链路是拥塞的。如果把这两种情况的数据包也纳入LLR的计算范围，显然得出的结果不会准确

    我们通过使用两种不同的标识，来区分前两种情况和第三种情况的数据包：如果数据包满足第三种情况，就给他生成一个独特标识(distinct capability)，否则给他生成一个公共标识(commom capability)。

    只有独特标识才会被CHM返回，并被mbox用以计算LLR

    所以，将*下游链路丢失的包*，重新定义为：

    如果这个数据包满足独特标识的条件，而他的独特标识没有在周期内返回，则认为，这个数据包是丢失的

1. 计算标识

    假设si在ts时刻发送了一个数据包，如果这个数据包满足条件：
    1. ts - TA < Dp - Th_rtt
    2. Pid < Th_cap
    那么，给这个数据包生成一个独特标识(distinct capability)，否则生成一个公共标识(commom capability)

    两个标识的区别是：只有独特标识会返回，以及用于计算LLR，公共标识不会被返回

    不等式1就是上面说的第三种情况的数据包

    公共标识虽然不会被返回，也不会被用于计算LLR，但是CHM可以通过这个标识来确认，这个数据包是通过了上游某个mbox，这是解决旁路攻击的依据

2. 标识的反馈验证 - WV

    WV用来标记哪些独特标识已经被返回，哪些是丢失的

    为了防止重复验证，mbox收到CHM返回的标识之后，会首先验证这个标识是否属于当前周期，然后才检查这个标识的ID，以此确认CHM接收到了哪个包

3. 计算LLR

    LLR指定是，在单个周期内，si的丢包率，所以，LLR可以表示为：

    LLR = (一个周期内si丢失的包的总数)/(一个周期内si发送的包的总数)

    在一个周期内，mbox丢弃的最努力包数量：ND

    下游丢包率：(V0/Pid)

    发到下游的包的总数：(NR-ND)

    下游包丢失的总数：(NR-ND)*(V0/Pid)

    LLR = ((NR-ND)*(V0/Pid) + ND)/NR

    考虑到TCP的超时问题，最终公式为：

    LLR = 0, if NR < Th_lPass

    LLR = ((NR-ND)*(V0/Pid) + ND)/NR, otherwise

#### SLR

SLR指的是某个mbox的下游丢包率

SLR的作用是，在RRT粒度下，反映下游拥塞情况（几乎是实时的下游拥塞情况），SLR计算的是从mbox到目标服务器的所有发送源

计算SLR依赖与另一张表，cTable

这是一个哈希表，长度是S_slr，key是独特标识，value是一个单比特值，0表示没有收到这个独特标识，1表示收到了

注意这里和WV的区别，由于SLR计算的是从mbox到目标服务器的所有发送源,所以这张表的独特标识包含了所有连接到这个mbox的发送方，而WV是si的一个属性，每个发送方都有自己的WV来记录自己独特标识的返回情况

这张表的填充逻辑是这样的：

当任意发送方的一个数据包到达mbox，且满足条件

1. 满足添加独特标识的条件
2. cTale的长度没有超过S_slr

mbox就将生成的独特标识添加到cTable，等待CHM的返回

如果这是第S_slr个被添加的记录，mbox记录下现在的时间戳T_slr

当任意发送方的一个数据包到达mbox(设它的到达时间为ta)，且cTable的长度已经到达S_slr，如果满足条件：

1. ta > T_slr + Th_rtt

开始计算SLR：SLR = Z0/S_slr,Z0是此时cTable中value为0的数量，然后重置cTable，开始新一轮的监视

否则，将T_slr刷新为ta，等待下一个数据包到达触发计算SLR的条件

- 关于不等式 ta > T_slr + Th_rtt

    在cTable里面，第一个被添加的记录拥有最多的时间等到CHM返回标识，而后续添加的记录，则要在越来越少的时间内，等待CHM返回标识。这个不等式保证了最后一个添加的记录也有最多一个RTT的时间去等待标识的返回

至此，已经完成了除WR之外所有变量的计算，下面将变量的计算过程总，使用算法来进行描述

### 4. 流量控制算法

![Alt alg1](alg1.png)
![Alt alg2](alg2.png)
![Alt alg3](alg3.png)

### 5. 流量管理策略的实现 - BandwidthAllocationPolicy(F)

BandwidthAllocationPolicy(F)是计算WR的模块，通过这个模块，用户可以自己选择要实现的流量管理策略

这篇文章的意图不在于提出一个好的流量管理算法，所以这里只实现了一些典型的流量管理算法（带宽分配算法 - band allocation algorithms），包括：

- Nature Share
- PerSenderFairshare
- PerASFairshare
- PerASPerSenderFairshare
- PremiumClientSupport

### 6. 包过滤

在受害者IP暴露的情况下，有可能会收到攻击者绕过mbox的旁路攻击

文章基于配置了ACL的商业路由器提出了一种方法

每个mbox将它要转发的包封装到UDP包中(类似VXLAN以及 [34](T. Herbert, “UDP encapsulation in linux,” in Proc.Tech. Conf. Linux Netw., 2015, pp. 1–44.))

并使用UDP源端口和目的端口（共32位）来携带共享秘钥，这个共享秘钥只有mbox和过滤点知道

通过这个秘钥的验证来判断数据包是否属于mbox转发

### 7. 源认证

这里文章只提出了基于HTTP/HTTPS源认证的POC

假设正常用户访问`victim.com`，mbox通过包里面的head信息获取到这个域名，然后这个数据包声称的源地址，加密生成一个token，`T`，并将这个token添加到原来的域名，构成一个新的主机地址`T.victim.com`，然后利用给用户返回一个302

如果是正常用户，会收到这个重定向的包，并重新访问`T.victim.com`，mbox收到之后，重新计算一次`T`，并和主机记录中的T进行匹对，如果正确，则转发，否则再发一个302给用户

如果是攻击者，由于使用的是一个伪造的源地址，所以收不到这个重定向的包

这个方法仅支持HTTP/HTTPS，而且容易受到DOS攻击，攻击这可以给mbox发送大量的新连接，来降低正常用户的连接速度

### 8. 完整的系统结构

![Alt all](all.png)

## 六、总结

MiddlePlice明确地解决了三个挑战：

1. `MiddlePolice`设计了一种只需要很少部署量的标识机制(
capability mechanism),这种机制依靠于云,而不是大规
模的网络升级

2. `MiddlePolice`是完全目标驱动的,它解决了现有的DDOS
防御系统缺点,即只能工作在特定的协议或者只能工作在预定
义了流量管理策略的提供商

3. `MiddlePolice`解决了基于云的解决方案出现的一个漏洞-旁
路攻击

大量的基于网络、实验环境、大规模模拟的实验,验证了`MiddlePolice`的部署性以及在执行了目标驱动的流量管理策
略的性能

## 七、我的问题

1. 这个系统没有真正地解决源欺骗攻击的问题

2. Natureshare在reactive attack下效果很差,而对于
PerSenderFairShare,在抵御攻击的场景下的确表现优秀,但
是在面对非攻击的场景下,性能是否可以接受?

3. 特定于企业的流量管理策略

这也是作者团队在研究的问题，系统确实可以实现，用户自己选择流量管理策略

但是要如何制定适合企业自身的流量管理策略？